<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/aidominance/presentation/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/aidominance/presentation/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.example.aidominance.presentation.navigation&#10;&#10;sealed class Screen(val route: String) {&#10;    object Dashboard : Screen(&quot;dashboard&quot;)&#10;    object SubmitStandup : Screen(&quot;submit_standup&quot;)&#10;    object History : Screen(&quot;history&quot;)&#10;    object Settings : Screen(&quot;settings&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/core/navigation/Destinations.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/core/navigation/Destinations.kt" />
              <option name="updatedContent" value="package com.example.logger.core.navigation&#10;&#10;object Destinations {&#10;    const val HOME = &quot;home&quot;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/data/remote/api/LoggerApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/data/remote/api/LoggerApi.kt" />
              <option name="originalContent" value="package com.example.logger.data.remote.api&#10;&#10;import com.example.logger.data.remote.dto.SampleDto&#10;import com.example.logger.data.remote.dto.StandupResponseDto&#10;import retrofit2.http.GET&#10;&#10;interface LoggerApi {&#10;    @GET(&quot;sample&quot;)&#10;    suspend fun getSamples(): List&lt;SampleDto&gt;&#10;&#10;    @GET(&quot;standup/today&quot;)&#10;    suspend fun getStandup(): StandupResponseDto&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.logger.data.remote.api&#10;&#10;import com.example.logger.data.remote.dto.SampleDto&#10;import com.example.logger.data.remote.dto.StandupResponseDto&#10;import com.example.logger.data.remote.dto.SubmitStandupRequestDto&#10;import retrofit2.http.Body&#10;import retrofit2.http.GET&#10;import retrofit2.http.POST&#10;&#10;interface LoggerApi {&#10;    @GET(&quot;sample&quot;)&#10;    suspend fun getSamples(): List&lt;SampleDto&gt;&#10;&#10;    @GET(&quot;standup/today&quot;)&#10;    suspend fun getStandup(): StandupResponseDto&#10;&#10;    @POST(&quot;standup&quot;)&#10;    suspend fun submitStandup(@Body body: SubmitStandupRequestDto)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/data/remote/dto/SubmitStandupRequestDto.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/data/remote/dto/SubmitStandupRequestDto.kt" />
              <option name="updatedContent" value="package com.example.logger.data.remote.dto&#10;&#10;data class SubmitStandupRequestDto(&#10;    val name: String,&#10;    val yesterday: String,&#10;    val today: String,&#10;    val blockers: String?&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/data/repository/StandupRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/data/repository/StandupRepositoryImpl.kt" />
              <option name="originalContent" value="package com.example.logger.data.repository&#10;&#10;import com.example.logger.core.network.NetworkResult&#10;import com.example.logger.data.mapper.toDomain&#10;import com.example.logger.data.remote.api.LoggerApi&#10;import com.example.logger.domain.model.StandupDay&#10;import com.example.logger.domain.repository.StandupRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class StandupRepositoryImpl @Inject constructor(&#10;    private val api: LoggerApi&#10;) : StandupRepository {&#10;    override fun getTodayStandup(): Flow&lt;NetworkResult&lt;StandupDay&gt;&gt; = flow {&#10;        try {&#10;            val dto = api.getStandup()&#10;            emit(NetworkResult.Success(dto.toDomain()))&#10;        } catch (e: Exception) {&#10;            emit(NetworkResult.Error(message = e.message, throwable = e))&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.logger.data.repository&#10;&#10;import com.example.logger.core.network.NetworkResult&#10;import com.example.logger.data.mapper.toDomain&#10;import com.example.logger.data.remote.api.LoggerApi&#10;import com.example.logger.data.remote.dto.SubmitStandupRequestDto&#10;import com.example.logger.domain.model.StandupDay&#10;import com.example.logger.domain.repository.StandupRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class StandupRepositoryImpl @Inject constructor(&#10;    private val api: LoggerApi&#10;) : StandupRepository {&#10;    override fun getTodayStandup(): Flow&lt;NetworkResult&lt;StandupDay&gt;&gt; = flow {&#10;        try {&#10;            val dto = api.getStandup()&#10;            emit(NetworkResult.Success(dto.toDomain()))&#10;        } catch (e: Exception) {&#10;            emit(NetworkResult.Error(message = e.message, throwable = e))&#10;        }&#10;    }&#10;&#10;    override suspend fun submitStandup(&#10;        name: String,&#10;        yesterday: String,&#10;        today: String,&#10;        blockers: String?&#10;    ): NetworkResult&lt;Unit&gt; {&#10;        return try {&#10;            api.submitStandup(&#10;                SubmitStandupRequestDto(&#10;                    name = name,&#10;                    yesterday = yesterday,&#10;                    today = today,&#10;                    blockers = blockers&#10;                )&#10;            )&#10;            NetworkResult.Success(Unit)&#10;        } catch (e: Exception) {&#10;            NetworkResult.Error(message = e.message, throwable = e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/domain/model/Standup.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/domain/model/Standup.kt" />
              <option name="updatedContent" value="package com.example.logger.domain.model&#10;&#10;data class Standup(&#10;    val id: String,&#10;    val name: String,&#10;    val yesterday: String,&#10;    val today: String,&#10;    val blockers: String?,&#10;    val time: String,&#10;    val editedAt: String?&#10;)&#10;&#10;data class StandupDay(&#10;    val date: String,&#10;    val roster: List&lt;String&gt;,&#10;    val submissions: List&lt;Standup&gt;&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/domain/repository/StandupRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/domain/repository/StandupRepository.kt" />
              <option name="originalContent" value="package com.example.logger.domain.repository&#10;&#10;import com.example.logger.core.network.NetworkResult&#10;import com.example.logger.domain.model.StandupDay&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;interface StandupRepository {&#10;    fun getTodayStandup(): Flow&lt;NetworkResult&lt;StandupDay&gt;&gt;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.logger.domain.repository&#10;&#10;import com.example.logger.core.network.NetworkResult&#10;import com.example.logger.domain.model.StandupDay&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;interface StandupRepository {&#10;    fun getTodayStandup(): Flow&lt;NetworkResult&lt;StandupDay&gt;&gt;&#10;    suspend fun submitStandup(&#10;        name: String,&#10;        yesterday: String,&#10;        today: String,&#10;        blockers: String?&#10;    ): NetworkResult&lt;Unit&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/domain/usecase/SubmitStandupUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/domain/usecase/SubmitStandupUseCase.kt" />
              <option name="updatedContent" value="package com.example.logger.domain.usecase&#10;&#10;import com.example.logger.core.network.NetworkResult&#10;import com.example.logger.domain.repository.StandupRepository&#10;import javax.inject.Inject&#10;&#10;class SubmitStandupUseCase @Inject constructor(&#10;    private val repository: StandupRepository&#10;) {&#10;    suspend operator fun invoke(&#10;        name: String,&#10;        yesterday: String,&#10;        today: String,&#10;        blockers: String?&#10;    ): NetworkResult&lt;Unit&gt; = repository.submitStandup(name, yesterday, today, blockers)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/dashboard/DashboardScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/dashboard/DashboardScreen.kt" />
              <option name="originalContent" value="package com.example.logger.presentation.dashboard&#10;&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.outlined.Dashboard&#10;import androidx.compose.material.icons.outlined.EditNote&#10;import androidx.compose.material.icons.outlined.EventNote&#10;import androidx.compose.material.icons.outlined.Settings&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.res.stringResource&#10;import com.example.logger.R&#10;import com.example.logger.presentation.home.HomeRoute&#10;import com.example.logger.presentation.home.HomeViewModel&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;&#10;@Composable&#10;fun DashboardScreen(&#10;    onNavigateSubmit: () -&gt; Unit = {},&#10;    onNavigateHistory: () -&gt; Unit = {},&#10;    onNavigateSettings: () -&gt; Unit = {}&#10;) {&#10;    // Body-only Home content, RootScaffold provides FAB and bottom bar&#10;    val vm: HomeViewModel = hiltViewModel()&#10;    HomeRoute(viewModel = vm)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.logger.presentation.dashboard&#10;&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.outlined.Dashboard&#10;import androidx.compose.material.icons.outlined.EditNote&#10;import androidx.compose.material.icons.outlined.EventNote&#10;import androidx.compose.material.icons.outlined.Settings&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.res.stringResource&#10;import com.example.logger.R&#10;import com.example.logger.presentation.home.HomeRoute&#10;import com.example.logger.presentation.home.HomeViewModel&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;&#10;@Composable&#10;fun DashboardScreen(&#10;    onNavigateSubmit: () -&gt; Unit = {},&#10;    onNavigateHistory: () -&gt; Unit = {},&#10;    onNavigateSettings: () -&gt; Unit = {},&#10;    onNavigateMissing: () -&gt; Unit = {},&#10;) {&#10;    // Body-only Home content, RootScaffold provides FAB and bottom bar&#10;    val vm: HomeViewModel = hiltViewModel()&#10;    HomeRoute(&#10;        viewModel = vm,&#10;        onViewMissing = onNavigateMissing,&#10;        onSubmit = onNavigateSubmit,&#10;        onExport = { /* TODO: export */ }&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/dashboard/ui/DashboardScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/dashboard/ui/DashboardScreen.kt" />
              <option name="updatedContent" value="package com.example.logger.presentation.dashboard.ui&#10;&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.outlined.Dashboard&#10;import androidx.compose.material.icons.outlined.EditNote&#10;import androidx.compose.material.icons.outlined.EventNote&#10;import androidx.compose.material.icons.outlined.Settings&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.example.logger.presentation.home.HomeRoute&#10;import com.example.logger.ui.theme.LoggerTheme&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.logger.presentation.home.HomeViewModel&#10;&#10;@Composable&#10;fun DashboardScreen() {&#10;    var selectedTab by remember { mutableStateOf(DashboardTab.Home) }&#10;&#10;    Scaffold(&#10;        bottomBar = {&#10;            NavigationBar {&#10;                DashboardTab.entries.forEach { tab -&gt;&#10;                    NavigationBarItem(&#10;                        selected = selectedTab == tab,&#10;                        onClick = { selectedTab = tab },&#10;                        icon = { Icon(tab.icon, contentDescription = tab.label) },&#10;                        label = { Text(tab.label) }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    ) { padding -&gt;&#10;        when (selectedTab) {&#10;            DashboardTab.Home -&gt; {&#10;                val vm: HomeViewModel = hiltViewModel()&#10;                HomeRoute(viewModel = vm)&#10;            }&#10;            DashboardTab.Submit -&gt; BlankTab(label = &quot;Submit&quot;)&#10;            DashboardTab.History -&gt; BlankTab(label = &quot;History&quot;)&#10;            DashboardTab.Settings -&gt; BlankTab(label = &quot;Settings&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;private enum class DashboardTab(val label: String, val icon: androidx.compose.ui.graphics.vector.ImageVector) {&#10;    Home(&quot;Home&quot;, Icons.Outlined.Dashboard),&#10;    Submit(&quot;Submit&quot;, Icons.Outlined.EditNote),&#10;    History(&quot;History&quot;, Icons.Outlined.EventNote),&#10;    Settings(&quot;Setting&quot;, Icons.Outlined.Settings);&#10;&#10;    companion object {&#10;        val entries = values().toList()&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun BlankTab(label: String) {&#10;    Text(&#10;        text = &quot;$label&quot;,&#10;        style = MaterialTheme.typography.titleLarge,&#10;        modifier = Modifier&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;private fun DashboardPreview() {&#10;    LoggerTheme { DashboardScreen() }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/navigation/AppNavHost.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/navigation/AppNavHost.kt" />
              <option name="originalContent" value="package com.example.logger.presentation.navigation&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.logger.presentation.dashboard.DashboardScreen&#10;import com.example.logger.presentation.home.HomeRoute&#10;import com.example.logger.presentation.home.HomeViewModel&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.logger.presentation.splash.SplashScreen&#10;import com.example.logger.presentation.submitstandup.SubmitConfirmScreen&#10;import com.example.logger.presentation.submitstandup.SubmitStandupScreen&#10;import com.example.logger.presentation.submitstandup.SubmitStandupViewModel&#10;import androidx.navigation.NavType&#10;import androidx.navigation.navArgument&#10;import com.example.logger.presentation.history.HistoryScreen&#10;import com.example.logger.presentation.settings.SettingsScreen&#10;import com.example.logger.presentation.roster.RosterScreen&#10;import androidx.compose.runtime.collectAsState&#10;import com.example.logger.presentation.missing.MissingScreen&#10;&#10;@Composable&#10;fun AppNavHost() {&#10;    val navController = rememberNavController()&#10;    // Render Splash outside of RootScaffold to prevent chrome flash&#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = Destinations.SPLASH&#10;    ) {&#10;        composable(Destinations.SPLASH) {&#10;            SplashScreen(&#10;                onGetStarted = {&#10;                    navController.navigate(Destinations.DASHBOARD) {&#10;                        popUpTo(Destinations.SPLASH) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                },&#10;                onConfigureSettings = {&#10;                    navController.navigate(Destinations.DASHBOARD) {&#10;                        popUpTo(Destinations.SPLASH) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            )&#10;        }&#10;        // Wrap the rest inside RootScaffold&#10;        composable(Destinations.DASHBOARD) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    DashboardScreen(&#10;                        onNavigateSubmit = {&#10;                            navController.navigate(Destinations.SUBMIT_STANDUP) {&#10;                                popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        },&#10;                        onNavigateHistory = {&#10;                            navController.navigate(Destinations.HISTORY) {&#10;                                popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        },&#10;                        onNavigateSettings = { /* TODO: add settings destination when available */ }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        composable(Destinations.HOME) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    val vm: HomeViewModel = hiltViewModel()&#10;                    HomeRoute(viewModel = vm)&#10;                }&#10;            }&#10;        }&#10;        composable(Destinations.SUBMIT_STANDUP) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    val vm: SubmitStandupViewModel = hiltViewModel()&#10;                    SubmitStandupScreen(&#10;                        viewModel = vm,&#10;                        onSubmitted = { ts -&gt;&#10;                            navController.navigate(Destinations.submitConfirm(ts)) {&#10;                                // Remove Submit from back stack so back from Success doesn’t return to Submit&#10;                                popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        },&#10;                        onCancel = { navController.popBackStack() },&#10;                        onNavigateHome = { navController.navigate(Destinations.DASHBOARD) },&#10;                        onNavigateSubmit = { /* stay on current submit screen */ },&#10;                        onNavigateHistory = { navController.navigate(Destinations.HISTORY) },&#10;                        onNavigateSettings = { /* TODO: add settings destination when available */ }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        composable(&#10;            route = Destinations.SUBMIT_CONFIRM,&#10;            arguments = listOf(navArgument(Destinations.ARG_TS) { type = NavType.StringType })&#10;        ) { backStackEntry -&gt;&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                val ts = backStackEntry.arguments?.getString(Destinations.ARG_TS) ?: &quot;&quot;&#10;                SubmitConfirmScreen(&#10;                    timestamp = ts,&#10;                    onGoDashboard = {&#10;                        navController.navigate(Destinations.DASHBOARD) {&#10;                            // Clear Success from back stack by popping to Dashboard&#10;                            popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                            launchSingleTop = true&#10;                            restoreState = true&#10;                        }&#10;                    },&#10;                    onGoHistory = {&#10;                        navController.navigate(Destinations.HISTORY) {&#10;                            popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                            launchSingleTop = true&#10;                            restoreState = true&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;        composable(Destinations.HISTORY) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    HistoryScreen(onNavigateBack = { navController.popBackStack() })&#10;                }&#10;            }&#10;        }&#10;        composable(Destinations.SETTINGS) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    SettingsScreen(onNavigateRoster = { navController.navigate(Destinations.ROSTER) })&#10;                }&#10;            }&#10;        }&#10;        composable(Destinations.ROSTER) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    val homeVm: HomeViewModel = hiltViewModel()&#10;                    val state = homeVm.uiState.collectAsState()&#10;                    RosterScreen(&#10;                        members = state.value.roster,&#10;                        onNavigateBack = { navController.popBackStack() }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        // Missing standups screen route&#10;        composable(Destinations.MISSING) {&#10;            // Missing should not show FAB or bottom bar according to requirements.&#10;            // Render without RootScaffold to hide chrome.&#10;            val homeVm: HomeViewModel = hiltViewModel()&#10;            val state = homeVm.uiState.collectAsState()&#10;            MissingScreen(&#10;                roster = state.value.roster,&#10;                submittedNames = state.value.submissions.map { it.name },&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onSendReminder = { /* TODO: hook reminder send; for now no-op */ }&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.logger.presentation.navigation&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.logger.presentation.dashboard.DashboardScreen&#10;import com.example.logger.presentation.home.HomeRoute&#10;import com.example.logger.presentation.home.HomeViewModel&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.logger.presentation.splash.SplashScreen&#10;import com.example.logger.presentation.submitstandup.SubmitConfirmScreen&#10;import com.example.logger.presentation.submitstandup.SubmitStandupScreen&#10;import com.example.logger.presentation.submitstandup.SubmitStandupViewModel&#10;import androidx.navigation.NavType&#10;import androidx.navigation.navArgument&#10;import com.example.logger.presentation.history.HistoryScreen&#10;import com.example.logger.presentation.settings.SettingsScreen&#10;import com.example.logger.presentation.roster.RosterScreen&#10;import androidx.compose.runtime.collectAsState&#10;import com.example.logger.presentation.missing.MissingScreen&#10;&#10;@Composable&#10;fun AppNavHost() {&#10;    val navController = rememberNavController()&#10;    // Render Splash outside of RootScaffold to prevent chrome flash&#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = Destinations.SPLASH&#10;    ) {&#10;        composable(Destinations.SPLASH) {&#10;            SplashScreen(&#10;                onGetStarted = {&#10;                    navController.navigate(Destinations.DASHBOARD) {&#10;                        popUpTo(Destinations.SPLASH) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                },&#10;                onConfigureSettings = {&#10;                    navController.navigate(Destinations.DASHBOARD) {&#10;                        popUpTo(Destinations.SPLASH) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            )&#10;        }&#10;        // Wrap the rest inside RootScaffold&#10;        composable(Destinations.DASHBOARD) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    DashboardScreen(&#10;                        onNavigateSubmit = {&#10;                            navController.navigate(Destinations.SUBMIT_STANDUP) {&#10;                                popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        },&#10;                        onNavigateHistory = {&#10;                            navController.navigate(Destinations.HISTORY) {&#10;                                popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        },&#10;                        onNavigateSettings = { /* TODO: add settings destination when available */ },&#10;                        onNavigateMissing = {&#10;                            navController.navigate(Destinations.MISSING) {&#10;                                popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        composable(Destinations.HOME) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    val vm: HomeViewModel = hiltViewModel()&#10;                    HomeRoute(viewModel = vm)&#10;                }&#10;            }&#10;        }&#10;        composable(Destinations.SUBMIT_STANDUP) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    val vm: SubmitStandupViewModel = hiltViewModel()&#10;                    SubmitStandupScreen(&#10;                        viewModel = vm,&#10;                        onSubmitted = { ts -&gt;&#10;                            navController.navigate(Destinations.submitConfirm(ts)) {&#10;                                // Remove Submit from back stack so back from Success doesn’t return to Submit&#10;                                popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        },&#10;                        onCancel = { navController.popBackStack() },&#10;                        onNavigateHome = { navController.navigate(Destinations.DASHBOARD) },&#10;                        onNavigateSubmit = { /* stay on current submit screen */ },&#10;                        onNavigateHistory = { navController.navigate(Destinations.HISTORY) },&#10;                        onNavigateSettings = { /* TODO: add settings destination when available */ }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        composable(&#10;            route = Destinations.SUBMIT_CONFIRM,&#10;            arguments = listOf(navArgument(Destinations.ARG_TS) { type = NavType.StringType })&#10;        ) { backStackEntry -&gt;&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                val ts = backStackEntry.arguments?.getString(Destinations.ARG_TS) ?: &quot;&quot;&#10;                SubmitConfirmScreen(&#10;                    timestamp = ts,&#10;                    onGoDashboard = {&#10;                        navController.navigate(Destinations.DASHBOARD) {&#10;                            // Clear Success from back stack by popping to Dashboard&#10;                            popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                            launchSingleTop = true&#10;                            restoreState = true&#10;                        }&#10;                    },&#10;                    onGoHistory = {&#10;                        navController.navigate(Destinations.HISTORY) {&#10;                            popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                            launchSingleTop = true&#10;                            restoreState = true&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;        composable(Destinations.HISTORY) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    HistoryScreen(onNavigateBack = { navController.popBackStack() })&#10;                }&#10;            }&#10;        }&#10;        composable(Destinations.SETTINGS) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    SettingsScreen(onNavigateRoster = { navController.navigate(Destinations.ROSTER) })&#10;                }&#10;            }&#10;        }&#10;        composable(Destinations.ROSTER) {&#10;            RootScaffold(navController = navController) { padding -&gt;&#10;                Box(Modifier.padding(padding)) {&#10;                    val homeVm: HomeViewModel = hiltViewModel()&#10;                    val state = homeVm.uiState.collectAsState()&#10;                    RosterScreen(&#10;                        members = state.value.roster,&#10;                        onNavigateBack = { navController.popBackStack() }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        // Missing standups screen route&#10;        composable(Destinations.MISSING) {&#10;            // Missing should not show FAB or bottom bar according to requirements.&#10;            // Render without RootScaffold to hide chrome.&#10;            val homeVm: HomeViewModel = hiltViewModel()&#10;            val state = homeVm.uiState.collectAsState()&#10;            MissingScreen(&#10;                roster = state.value.roster,&#10;                submittedNames = state.value.submissions.map { it.name },&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onSendReminder = { /* TODO: hook reminder send; for now no-op */ }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/navigation/RootScaffold.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/navigation/RootScaffold.kt" />
              <option name="originalContent" value="package com.example.logger.presentation.navigation&#10;&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.outlined.EventNote&#10;import androidx.compose.material.icons.outlined.Dashboard&#10;import androidx.compose.material.icons.outlined.EditNote&#10;import androidx.compose.material.icons.outlined.Settings&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.navigation.NavGraph.Companion.findStartDestination&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import com.example.logger.R&#10;&#10;private enum class RootTab(val route: String, val labelRes: Int, val icon: ImageVector) {&#10;    Home(Destinations.DASHBOARD, R.string.home, Icons.Outlined.Dashboard),&#10;    Submit(Destinations.SUBMIT_STANDUP, R.string.submit, Icons.Outlined.EditNote),&#10;    History(Destinations.HISTORY, R.string.history, Icons.AutoMirrored.Outlined.EventNote),&#10;    Settings(&quot;settings&quot;, R.string.settings, Icons.Outlined.Settings)&#10;}&#10;&#10;private fun mapRouteToTab(route: String?): RootTab = when {&#10;    route == Destinations.DASHBOARD || route == Destinations.HOME -&gt; RootTab.Home&#10;    route == Destinations.SUBMIT_STANDUP || (route?.startsWith(Destinations.SUBMIT_CONFIRM) == true) -&gt; RootTab.Submit&#10;    route == Destinations.HISTORY -&gt; RootTab.History&#10;    route == Destinations.SETTINGS -&gt; RootTab.Settings&#10;    else -&gt; RootTab.Home&#10;}&#10;&#10;@Composable&#10;fun RootScaffold(&#10;    navController: NavHostController,&#10;    content: @Composable (PaddingValues) -&gt; Unit&#10;) {&#10;    val tabs = remember { RootTab.entries }&#10;    val backStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = backStackEntry?.destination?.route&#10;    val selectedTab = mapRouteToTab(currentRoute)&#10;    val isChromeVisible = currentRoute != Destinations.SPLASH &amp;&amp; currentRoute != Destinations.ROSTER&#10;&#10;    Scaffold(&#10;        contentWindowInsets = WindowInsets(0),&#10;        floatingActionButton = {&#10;            if (isChromeVisible &amp;&amp; selectedTab == RootTab.Home) {&#10;                FloatingActionButton(&#10;                    onClick = {&#10;                        navController.navigate(Destinations.SUBMIT_STANDUP) {&#10;                            popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                            launchSingleTop = true&#10;                            restoreState = true&#10;                        }&#10;                    },&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    contentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    shape = MaterialTheme.shapes.medium&#10;                ) {&#10;                    Icon(Icons.Outlined.EditNote, contentDescription = stringResource(R.string.submit))&#10;                }&#10;            }&#10;        },&#10;        bottomBar = {&#10;            if (isChromeVisible) {&#10;                NavigationBar {&#10;                    tabs.forEach { tab -&gt;&#10;                        NavigationBarItem(&#10;                            selected = selectedTab == tab,&#10;                            onClick = {&#10;                                when (tab) {&#10;                                    RootTab.Home -&gt; {&#10;                                        val current = navController.currentBackStackEntry?.destination?.route&#10;                                        if (current != Destinations.DASHBOARD) {&#10;                                            val popped = navController.popBackStack(Destinations.DASHBOARD, inclusive = false)&#10;                                            if (!popped) {&#10;                                                navController.navigate(Destinations.DASHBOARD) {&#10;                                                    popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                                    launchSingleTop = true&#10;                                                    restoreState = true&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                    RootTab.Submit -&gt; {&#10;                                        // Avoid restoreState to guarantee fresh screen after coming from History or Success&#10;                                        navController.navigate(Destinations.SUBMIT_STANDUP) {&#10;                                            popUpTo(Destinations.DASHBOARD) { saveState = false }&#10;                                            launchSingleTop = true&#10;                                            restoreState = false&#10;                                        }&#10;                                    }&#10;                                    RootTab.History -&gt; {&#10;                                        navController.navigate(Destinations.HISTORY) {&#10;                                            popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                            launchSingleTop = true&#10;                                            restoreState = true&#10;                                        }&#10;                                    }&#10;                                    RootTab.Settings -&gt; {&#10;                                        navController.navigate(Destinations.SETTINGS) {&#10;                                            popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                            launchSingleTop = true&#10;                                            restoreState = true&#10;                                        }&#10;                                    }&#10;                                }&#10;                            },&#10;                            icon = { Icon(tab.icon, contentDescription = stringResource(tab.labelRes)) },&#10;                            label = { Text(stringResource(tab.labelRes)) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    ) { padding -&gt; content(padding) }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.logger.presentation.navigation&#10;&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.outlined.EventNote&#10;import androidx.compose.material.icons.outlined.Dashboard&#10;import androidx.compose.material.icons.outlined.EditNote&#10;import androidx.compose.material.icons.outlined.Settings&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.navigation.NavGraph.Companion.findStartDestination&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import com.example.logger.R&#10;&#10;private enum class RootTab(val route: String, val labelRes: Int, val icon: ImageVector) {&#10;    Home(Destinations.DASHBOARD, R.string.home, Icons.Outlined.Dashboard),&#10;    Submit(Destinations.SUBMIT_STANDUP, R.string.submit, Icons.Outlined.EditNote),&#10;    History(Destinations.HISTORY, R.string.history, Icons.AutoMirrored.Outlined.EventNote),&#10;    Settings(&quot;settings&quot;, R.string.settings, Icons.Outlined.Settings)&#10;}&#10;&#10;private fun mapRouteToTab(route: String?): RootTab = when {&#10;    route == Destinations.DASHBOARD || route == Destinations.HOME -&gt; RootTab.Home&#10;    route == Destinations.SUBMIT_STANDUP || (route?.startsWith(Destinations.SUBMIT_CONFIRM) == true) -&gt; RootTab.Submit&#10;    route == Destinations.HISTORY -&gt; RootTab.History&#10;    route == Destinations.SETTINGS -&gt; RootTab.Settings&#10;    else -&gt; RootTab.Home&#10;}&#10;&#10;@Composable&#10;fun RootScaffold(&#10;    navController: NavHostController,&#10;    content: @Composable (PaddingValues) -&gt; Unit&#10;) {&#10;    val tabs = remember { RootTab.entries }&#10;    val backStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = backStackEntry?.destination?.route&#10;    val selectedTab = mapRouteToTab(currentRoute)&#10;    val isChromeVisible = currentRoute != Destinations.SPLASH &amp;&amp; currentRoute != Destinations.ROSTER &amp;&amp; currentRoute != Destinations.MISSING&#10;&#10;    Scaffold(&#10;        contentWindowInsets = WindowInsets(0),&#10;        floatingActionButton = {&#10;            if (isChromeVisible &amp;&amp; selectedTab == RootTab.Home) {&#10;                FloatingActionButton(&#10;                    onClick = {&#10;                        navController.navigate(Destinations.SUBMIT_STANDUP) {&#10;                            popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                            launchSingleTop = true&#10;                            restoreState = true&#10;                        }&#10;                    },&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    contentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    shape = MaterialTheme.shapes.medium&#10;                ) {&#10;                    Icon(Icons.Outlined.EditNote, contentDescription = stringResource(R.string.submit))&#10;                }&#10;            }&#10;        },&#10;        bottomBar = {&#10;            if (isChromeVisible) {&#10;                NavigationBar {&#10;                    tabs.forEach { tab -&gt;&#10;                        NavigationBarItem(&#10;                            selected = selectedTab == tab,&#10;                            onClick = {&#10;                                when (tab) {&#10;                                    RootTab.Home -&gt; {&#10;                                        val current = navController.currentBackStackEntry?.destination?.route&#10;                                        if (current != Destinations.DASHBOARD) {&#10;                                            val popped = navController.popBackStack(Destinations.DASHBOARD, inclusive = false)&#10;                                            if (!popped) {&#10;                                                navController.navigate(Destinations.DASHBOARD) {&#10;                                                    popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                                    launchSingleTop = true&#10;                                                    restoreState = true&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                    RootTab.Submit -&gt; {&#10;                                        // Avoid restoreState to guarantee fresh screen after coming from History or Success&#10;                                        navController.navigate(Destinations.SUBMIT_STANDUP) {&#10;                                            popUpTo(Destinations.DASHBOARD) { saveState = false }&#10;                                            launchSingleTop = true&#10;                                            restoreState = false&#10;                                        }&#10;                                    }&#10;                                    RootTab.History -&gt; {&#10;                                        navController.navigate(Destinations.HISTORY) {&#10;                                            popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                            launchSingleTop = true&#10;                                            restoreState = true&#10;                                        }&#10;                                    }&#10;                                    RootTab.Settings -&gt; {&#10;                                        navController.navigate(Destinations.SETTINGS) {&#10;                                            popUpTo(Destinations.DASHBOARD) { saveState = true }&#10;                                            launchSingleTop = true&#10;                                            restoreState = true&#10;                                        }&#10;                                    }&#10;                                }&#10;                            },&#10;                            icon = { Icon(tab.icon, contentDescription = stringResource(tab.labelRes)) },&#10;                            label = { Text(stringResource(tab.labelRes)) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    ) { padding -&gt; content(padding) }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/splash/ui/SplashScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/splash/ui/SplashScreen.kt" />
              <option name="updatedContent" value="package com.example.logger.presentation.splash.ui&#10;&#10;// ...existing imports...&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.foundation.layout.widthIn&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;&#10;@Composable&#10;fun SplashScreen(&#10;    onGetStarted: () -&gt; Unit,&#10;    onConfigureSettings: () -&gt; Unit,&#10;) {&#10;    Column(&#10;        // ...existing code...&#10;    ) {&#10;        // ...existing code...&#10;        Spacer(Modifier.size(48.dp))&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(horizontal = 12.dp)&#10;                .widthIn(max = 280.dp)&#10;        ) {&#10;            Button(onClick = onGetStarted, modifier = Modifier.fillMaxWidth()) {&#10;                Icon(Icons.Outlined.Dashboard, contentDescription = null)&#10;                Spacer(Modifier.size(8.dp))&#10;                Text(&quot;Get Started&quot;)&#10;            }&#10;            Spacer(Modifier.size(12.dp))&#10;            Button(onClick = onConfigureSettings, modifier = Modifier.fillMaxWidth()) {&#10;                Icon(Icons.Outlined.Settings, contentDescription = null)&#10;                Spacer(Modifier.size(8.dp))&#10;                Text(&quot;Configure Settings&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// ...existing code..." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/submitstandup/SubmitStandupViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/presentation/submitstandup/SubmitStandupViewModel.kt" />
              <option name="originalContent" value="package com.example.logger.presentation.submitstandup&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.channels.Channel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.receiveAsFlow&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;data class SubmitStandupUiState(&#10;    val name: String = &quot;&quot;,&#10;    val yesterday: String = &quot;&quot;,&#10;    val today: String = &quot;&quot;,&#10;    val blockers: String = &quot;&quot;,&#10;    val isSubmitting: Boolean = false,&#10;    val error: String? = null,&#10;    val submittedAt: String? = null,&#10;    val roster: List&lt;String&gt; = emptyList(),&#10;    val nameError: Boolean = false,&#10;    val yesterdayError: Boolean = false,&#10;    val todayError: Boolean = false&#10;)&#10;&#10;sealed interface SubmitStandupUiEvent {&#10;    data class ApiError(val message: String): SubmitStandupUiEvent&#10;    object Submitted: SubmitStandupUiEvent&#10;}&#10;&#10;class SubmitStandupViewModel : ViewModel() {&#10;    private val _uiState = MutableStateFlow(SubmitStandupUiState())&#10;    val uiState: StateFlow&lt;SubmitStandupUiState&gt; = _uiState&#10;    private val _events = Channel&lt;SubmitStandupUiEvent&gt;(Channel.BUFFERED)&#10;    val events = _events.receiveAsFlow()&#10;&#10;    init {&#10;        // Hardcoded roster per wireframe&#10;        val defaultRoster = listOf(&quot;Alex Johnson&quot;,&quot;Priya Verma&quot;,&quot;Miguel Santos&quot;,&quot;Sarah Kim&quot;,&quot;You&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            roster = defaultRoster,&#10;            name = if (_uiState.value.name.isBlank()) &quot;You&quot; else _uiState.value.name&#10;        )&#10;    }&#10;&#10;    fun onNameChange(v: String) { _uiState.value = _uiState.value.copy(name = v, nameError = false) }&#10;    fun onYesterdayChange(v: String) { _uiState.value = _uiState.value.copy(yesterday = v, yesterdayError = false) }&#10;    fun onTodayChange(v: String) { _uiState.value = _uiState.value.copy(today = v, todayError = false) }&#10;    fun onBlockersChange(v: String) { _uiState.value = _uiState.value.copy(blockers = v) }&#10;&#10;    fun submit(onSuccess: (String) -&gt; Unit) {&#10;        val s = _uiState.value&#10;        val nameErr = s.name.isBlank()&#10;        val yErr = s.yesterday.isBlank()&#10;        val tErr = s.today.isBlank()&#10;        if (nameErr || yErr || tErr) {&#10;            _uiState.value = s.copy(&#10;                nameError = nameErr,&#10;                yesterdayError = yErr,&#10;                todayError = tErr,&#10;                error = null&#10;            )&#10;            return&#10;        }&#10;        _uiState.value = s.copy(isSubmitting = true, error = null)&#10;        // No API call for now: simulate success and navigate to confirm with timestamp&#10;        val ts = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault()).format(Date())&#10;        _uiState.value = _uiState.value.copy(isSubmitting = false, submittedAt = ts)&#10;        viewModelScope.launch { _events.send(SubmitStandupUiEvent.Submitted) }&#10;        onSuccess(ts)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.logger.presentation.submitstandup&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.logger.core.network.NetworkResult&#10;import com.example.logger.domain.usecase.GetTodayStandupUseCase&#10;import com.example.logger.domain.usecase.SubmitStandupUseCase&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.channels.Channel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.receiveAsFlow&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;import javax.inject.Inject&#10;&#10;data class SubmitStandupUiState(&#10;    val name: String = &quot;&quot;,&#10;    val yesterday: String = &quot;&quot;,&#10;    val today: String = &quot;&quot;,&#10;    val blockers: String = &quot;&quot;,&#10;    val isSubmitting: Boolean = false,&#10;    val error: String? = null,&#10;    val submittedAt: String? = null,&#10;    val roster: List&lt;String&gt; = emptyList(),&#10;    val nameError: Boolean = false,&#10;    val yesterdayError: Boolean = false,&#10;    val todayError: Boolean = false&#10;)&#10;&#10;sealed interface SubmitStandupUiEvent {&#10;    data class ApiError(val message: String): SubmitStandupUiEvent&#10;    object Submitted: SubmitStandupUiEvent&#10;}&#10;&#10;@HiltViewModel&#10;class SubmitStandupViewModel @Inject constructor(&#10;    private val submitUseCase: SubmitStandupUseCase,&#10;    private val getTodayStandupUseCase: GetTodayStandupUseCase&#10;) : ViewModel() {&#10;    private val _uiState = MutableStateFlow(SubmitStandupUiState())&#10;    val uiState: StateFlow&lt;SubmitStandupUiState&gt; = _uiState&#10;    private val _events = Channel&lt;SubmitStandupUiEvent&gt;(Channel.BUFFERED)&#10;    val events = _events.receiveAsFlow()&#10;&#10;    init {&#10;        // Hardcoded roster per wireframe&#10;        val defaultRoster = listOf(&quot;Alex Johnson&quot;,&quot;Priya Verma&quot;,&quot;Miguel Santos&quot;,&quot;Sarah Kim&quot;,&quot;You&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            roster = defaultRoster,&#10;            name = if (_uiState.value.name.isBlank()) &quot;You&quot; else _uiState.value.name&#10;        )&#10;        // Optionally merge API roster if present, but keep hardcoded as source of truth for now&#10;        viewModelScope.launch {&#10;            getTodayStandupUseCase().collect { res -&gt;&#10;                if (res is NetworkResult.Success) {&#10;                    // Merge unique names preserving order: hardcoded first, then any new ones&#10;                    val merged = (defaultRoster + res.data.roster).distinct()&#10;                    _uiState.value = _uiState.value.copy(roster = merged)&#10;                    if (_uiState.value.name.isBlank() &amp;&amp; merged.isNotEmpty()) {&#10;                        _uiState.value = _uiState.value.copy(name = if (merged.contains(&quot;You&quot;)) &quot;You&quot; else merged.first())&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onNameChange(v: String) { _uiState.value = _uiState.value.copy(name = v, nameError = false) }&#10;    fun onYesterdayChange(v: String) { _uiState.value = _uiState.value.copy(yesterday = v, yesterdayError = false) }&#10;    fun onTodayChange(v: String) { _uiState.value = _uiState.value.copy(today = v, todayError = false) }&#10;    fun onBlockersChange(v: String) { _uiState.value = _uiState.value.copy(blockers = v) }&#10;&#10;    fun submit(onSuccess: (String) -&gt; Unit) {&#10;        val s = _uiState.value&#10;        val nameErr = s.name.isBlank()&#10;        val yErr = s.yesterday.isBlank()&#10;        val tErr = s.today.isBlank()&#10;        if (nameErr || yErr || tErr) {&#10;            _uiState.value = s.copy(&#10;                nameError = nameErr,&#10;                yesterdayError = yErr,&#10;                todayError = tErr,&#10;                error = null&#10;            )&#10;            return&#10;        }&#10;        _uiState.value = s.copy(isSubmitting = true, error = null)&#10;        // No API call for now: simulate success and navigate to confirm with timestamp&#10;        val ts = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault()).format(Date())&#10;        _uiState.value = _uiState.value.copy(isSubmitting = false, submittedAt = ts)&#10;        viewModelScope.launch { _events.send(SubmitStandupUiEvent.Submitted) }&#10;        onSuccess(ts)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/ui/theme/Color.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/ui/theme/Color.kt" />
              <option name="originalContent" value="package com.example.logger.ui.theme&#10;&#10;import androidx.compose.ui.graphics.Color&#10;&#10;val Purple80 = Color(0xFFD0BCFF)&#10;val PurpleGrey80 = Color(0xFFCCC2DC)&#10;val Pink80 = Color(0xFFEFB8C8)&#10;&#10;val Purple40 = Color(0xFF6650a4)&#10;val PurpleGrey40 = Color(0xFF625b71)&#10;val Pink40 = Color(0xFF7D5260)&#10;&#10;val Primary = Color(0xFF3700B3)&#10;val OnPrimary = Color(0xFFFFFFFF)&#10;" />
              <option name="updatedContent" value="package com.example.logger.ui.theme&#10;&#10;import androidx.compose.ui.graphics.Color&#10;&#10;val Purple80 = Color(0xFFD0BCFF)&#10;val PurpleGrey80 = Color(0xFFCCC2DC)&#10;val Pink80 = Color(0xFFEFB8C8)&#10;&#10;val Purple40 = Color(0xFF6650a4)&#10;val PurpleGrey40 = Color(0xFF625b71)&#10;val Pink40 = Color(0xFF7D5260)&#10;&#10;val Primary = Color(0xFF6200EA)&#10;val OnPrimary = Color(0xFFFFFFFF)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/logger/ui/theme/Theme.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/logger/ui/theme/Theme.kt" />
              <option name="originalContent" value="package com.example.logger.ui.theme&#10;&#10;import android.app.Activity&#10;import android.os.Build&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.platform.LocalContext&#10;&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Purple80,&#10;    secondary = PurpleGrey80,&#10;    tertiary = Pink80&#10;)&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = Purple40,&#10;    secondary = PurpleGrey40,&#10;    tertiary = Pink40&#10;&#10;    /* Other default colors to override&#10;    background = Color(0xFFFFFBFE),&#10;    surface = Color(0xFFFFFBFE),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.White,&#10;    onTertiary = Color.White,&#10;    onBackground = Color(0xFF1C1B1F),&#10;    onSurface = Color(0xFF1C1B1F),&#10;    */&#10;)&#10;&#10;@Composable&#10;fun LoggerTheme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    // Dynamic color is available on Android 12+&#10;    dynamicColor: Boolean = true,&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val colorScheme = when {&#10;        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {&#10;            val context = LocalContext.current&#10;            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)&#10;        }&#10;&#10;        darkTheme -&gt; DarkColorScheme&#10;        else -&gt; LightColorScheme&#10;    }&#10;&#10;    MaterialTheme(&#10;        colorScheme = colorScheme,&#10;        typography = Typography,&#10;        content = content&#10;    )&#10;}" />
              <option name="updatedContent" value="package com.example.logger.ui.theme&#10;&#10;import android.app.Activity&#10;import android.os.Build&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.platform.LocalContext&#10;&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Primary,&#10;    onPrimary = OnPrimary,&#10;    secondary = PurpleGrey80,&#10;    tertiary = Pink80&#10;)&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = Primary,&#10;    onPrimary = OnPrimary,&#10;    secondary = PurpleGrey40,&#10;    tertiary = Pink40&#10;&#10;    /* Other default colors to override&#10;    background = Color(0xFFFFFBFE),&#10;    surface = Color(0xFFFFFBFE),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.White,&#10;    onTertiary = Color.White,&#10;    onBackground = Color(0xFF1C1B1F),&#10;    onSurface = Color(0xFF1C1B1F),&#10;    */&#10;)&#10;&#10;@Composable&#10;fun LoggerTheme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    // Dynamic color is available on Android 12+&#10;    dynamicColor: Boolean = false, // disable dynamic color to keep wireframe palette&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val colorScheme = when {&#10;        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {&#10;            val context = LocalContext.current&#10;            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)&#10;        }&#10;&#10;        darkTheme -&gt; DarkColorScheme&#10;        else -&gt; LightColorScheme&#10;    }&#10;&#10;    MaterialTheme(&#10;        colorScheme = colorScheme,&#10;        typography = Typography,&#10;        content = content&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/standuplogger/presentation/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/standuplogger/presentation/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.example.standuplogger.presentation.navigation&#10;&#10;sealed class Screen(val route: String) {&#10;    object Dashboard : Screen(&quot;dashboard&quot;)&#10;    object SubmitStandup : Screen(&quot;submit_standup&quot;)&#10;    object History : Screen(&quot;history&quot;)&#10;    object Settings : Screen(&quot;settings&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/strings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/strings.xml" />
              <option name="originalContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;Logger&lt;/string&gt;&#10;    &lt;string name=&quot;splash_title&quot;&gt;Daily Standup&lt;/string&gt;&#10;    &lt;string name=&quot;splash_subtitle&quot;&gt;Keep your team in sync with daily updates and track progress effortlessly.&lt;/string&gt;&#10;    &lt;string name=&quot;splash_get_started&quot;&gt;Get Started&lt;/string&gt;&#10;    &lt;string name=&quot;splash_configure_settings&quot;&gt;Configure Settings&lt;/string&gt;&#10;    &lt;string name=&quot;home&quot;&gt;Home&lt;/string&gt;&#10;    &lt;string name=&quot;submit&quot;&gt;Submit&lt;/string&gt;&#10;    &lt;string name=&quot;history&quot;&gt;History&lt;/string&gt;&#10;    &lt;string name=&quot;settings&quot;&gt;Settings&lt;/string&gt;&#10;&#10;    &lt;string name=&quot;submit_standup_title&quot;&gt;Submit Standup&lt;/string&gt;&#10;    &lt;string name=&quot;submit_standup_subtitle&quot;&gt;Share your progress with the team&lt;/string&gt;&#10;    &lt;string name=&quot;name_label&quot;&gt;Name&lt;/string&gt;&#10;    &lt;string name=&quot;yesterday_label&quot;&gt;What did you do yesterday?&lt;/string&gt;&#10;    &lt;string name=&quot;today_label&quot;&gt;What will you do today?&lt;/string&gt;&#10;    &lt;string name=&quot;blockers_label_optional&quot;&gt;Any blockers? (optional)&lt;/string&gt;&#10;    &lt;string name=&quot;required_fields_missing&quot;&gt;Please fill all required fields.&lt;/string&gt;&#10;    &lt;string name=&quot;unknown_error&quot;&gt;Something went wrong. Please try again.&lt;/string&gt;&#10;    &lt;string name=&quot;cancel&quot;&gt;Cancel&lt;/string&gt;&#10;    &lt;string name=&quot;back&quot;&gt;Back&lt;/string&gt;&#10;    &lt;string name=&quot;submitted_title&quot;&gt;Submitted!&lt;/string&gt;&#10;    &lt;string name=&quot;submitted_message&quot;&gt;Your standup was submitted at %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;dashboard&quot;&gt;Dashboard&lt;/string&gt;&#10;    &lt;string name=&quot;view_history&quot;&gt;View History&lt;/string&gt;&#10;    &lt;string name=&quot;confirm_next_actions_label&quot;&gt;What would you like to do next?&lt;/string&gt;&#10;&#10;    &lt;string name=&quot;history_title&quot;&gt;Standup History&lt;/string&gt;&#10;    &lt;string name=&quot;history_subtitle&quot;&gt;View past submissions&lt;/string&gt;&#10;    &lt;string name=&quot;select_date_label&quot;&gt;Select date&lt;/string&gt;&#10;    &lt;string name=&quot;pick_date&quot;&gt;Pick Date&lt;/string&gt;&#10;    &lt;string name=&quot;history_empty_title&quot;&gt;No standups&lt;/string&gt;&#10;    &lt;string name=&quot;history_empty_subtitle&quot;&gt;No submissions for this date&lt;/string&gt;&#10;&#10;    &lt;!-- Settings --&gt;&#10;    &lt;string name=&quot;settings_title&quot;&gt;Settings&lt;/string&gt;&#10;    &lt;string name=&quot;settings_subtitle&quot;&gt;App preferences&lt;/string&gt;&#10;    &lt;string name=&quot;settings_team_roster&quot;&gt;Team Roster&lt;/string&gt;&#10;    &lt;string name=&quot;settings_manage_team&quot;&gt;Manage team members&lt;/string&gt;&#10;    &lt;string name=&quot;settings_notifications&quot;&gt;Notifications&lt;/string&gt;&#10;    &lt;string name=&quot;settings_push_label&quot;&gt;Push notifications&lt;/string&gt;&#10;    &lt;string name=&quot;settings_push_desc&quot;&gt;Get reminders and updates&lt;/string&gt;&#10;    &lt;string name=&quot;settings_email_label&quot;&gt;Email notifications&lt;/string&gt;&#10;    &lt;string name=&quot;settings_email_desc&quot;&gt;Receive daily summaries&lt;/string&gt;&#10;&#10;    &lt;!-- Roster --&gt;&#10;    &lt;string name=&quot;roster_title&quot;&gt;Team Roster&lt;/string&gt;&#10;    &lt;string name=&quot;roster_members_count&quot;&gt;%1$d team member%2$s&lt;/string&gt;&#10;    &lt;string name=&quot;roster_empty_title&quot;&gt;No team members&lt;/string&gt;&#10;    &lt;string name=&quot;roster_empty_subtitle&quot;&gt;No team members configured&lt;/string&gt;&#10;    &lt;string name=&quot;roster_section_label&quot;&gt;TEAM MEMBERS&lt;/string&gt;&#10;    &lt;string name=&quot;roster_member_subtitle&quot;&gt;Team member %1$d&lt;/string&gt;&#10;&#10;    &lt;!-- Missing --&gt;&#10;    &lt;string name=&quot;missing_title&quot;&gt;Missing Standup&lt;/string&gt;&#10;    &lt;string name=&quot;missing_header&quot;&gt;Missing Today&lt;/string&gt;&#10;    &lt;string name=&quot;missing_members_count&quot;&gt;%1$d team member%2$s haven't submitted&lt;/string&gt;&#10;    &lt;string name=&quot;missing_empty_title&quot;&gt;All caught up!&lt;/string&gt;&#10;    &lt;string name=&quot;missing_empty_subtitle&quot;&gt;Everyone has submitted today&lt;/string&gt;&#10;    &lt;string name=&quot;missing_row_subtitle&quot;&gt;Not submitted yet&lt;/string&gt;&#10;    &lt;string name=&quot;remind&quot;&gt;Remind&lt;/string&gt;&#10;&lt;/resources&gt;" />
              <option name="updatedContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;Logger&lt;/string&gt;&#10;    &lt;string name=&quot;splash_title&quot;&gt;Daily Standup&lt;/string&gt;&#10;    &lt;string name=&quot;splash_subtitle&quot;&gt;Keep your team in sync with daily updates and track progress effortlessly.&lt;/string&gt;&#10;    &lt;string name=&quot;splash_get_started&quot;&gt;Get Started&lt;/string&gt;&#10;    &lt;string name=&quot;splash_configure_settings&quot;&gt;Configure Settings&lt;/string&gt;&#10;    &lt;string name=&quot;home&quot;&gt;Home&lt;/string&gt;&#10;    &lt;string name=&quot;submit&quot;&gt;Submit&lt;/string&gt;&#10;    &lt;string name=&quot;history&quot;&gt;History&lt;/string&gt;&#10;    &lt;string name=&quot;settings&quot;&gt;Settings&lt;/string&gt;&#10;&#10;    &lt;string name=&quot;submit_standup_title&quot;&gt;Submit Standup&lt;/string&gt;&#10;    &lt;string name=&quot;submit_standup_subtitle&quot;&gt;Share your progress with the team&lt;/string&gt;&#10;    &lt;string name=&quot;name_label&quot;&gt;Name&lt;/string&gt;&#10;    &lt;string name=&quot;yesterday_label&quot;&gt;What did you do yesterday?&lt;/string&gt;&#10;    &lt;string name=&quot;today_label&quot;&gt;What will you do today?&lt;/string&gt;&#10;    &lt;string name=&quot;blockers_label_optional&quot;&gt;Any blockers? (optional)&lt;/string&gt;&#10;    &lt;string name=&quot;required_fields_missing&quot;&gt;Please fill all required fields.&lt;/string&gt;&#10;    &lt;string name=&quot;unknown_error&quot;&gt;Something went wrong. Please try again.&lt;/string&gt;&#10;    &lt;string name=&quot;cancel&quot;&gt;Cancel&lt;/string&gt;&#10;    &lt;string name=&quot;back&quot;&gt;Back&lt;/string&gt;&#10;    &lt;string name=&quot;submitted_title&quot;&gt;Submitted!&lt;/string&gt;&#10;    &lt;string name=&quot;submitted_message&quot;&gt;Your standup was submitted at %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;dashboard&quot;&gt;Dashboard&lt;/string&gt;&#10;    &lt;string name=&quot;view_history&quot;&gt;View History&lt;/string&gt;&#10;    &lt;string name=&quot;confirm_next_actions_label&quot;&gt;What would you like to do next?&lt;/string&gt;&#10;&#10;    &lt;string name=&quot;history_title&quot;&gt;Standup History&lt;/string&gt;&#10;    &lt;string name=&quot;history_subtitle&quot;&gt;View past submissions&lt;/string&gt;&#10;    &lt;string name=&quot;select_date_label&quot;&gt;Select date&lt;/string&gt;&#10;    &lt;string name=&quot;pick_date&quot;&gt;Pick Date&lt;/string&gt;&#10;    &lt;string name=&quot;history_empty_title&quot;&gt;No standups&lt;/string&gt;&#10;    &lt;string name=&quot;history_empty_subtitle&quot;&gt;No submissions for this date&lt;/string&gt;&#10;&#10;    &lt;!-- Settings --&gt;&#10;    &lt;string name=&quot;settings_title&quot;&gt;Settings&lt;/string&gt;&#10;    &lt;string name=&quot;settings_subtitle&quot;&gt;App preferences&lt;/string&gt;&#10;    &lt;string name=&quot;settings_team_roster&quot;&gt;Team Roster&lt;/string&gt;&#10;    &lt;string name=&quot;settings_manage_team&quot;&gt;Manage team members&lt;/string&gt;&#10;    &lt;string name=&quot;settings_notifications&quot;&gt;Notifications&lt;/string&gt;&#10;    &lt;string name=&quot;settings_push_label&quot;&gt;Push notifications&lt;/string&gt;&#10;    &lt;string name=&quot;settings_push_desc&quot;&gt;Get reminders and updates&lt;/string&gt;&#10;    &lt;string name=&quot;settings_email_label&quot;&gt;Email notifications&lt;/string&gt;&#10;    &lt;string name=&quot;settings_email_desc&quot;&gt;Receive daily summaries&lt;/string&gt;&#10;&#10;    &lt;!-- Roster --&gt;&#10;    &lt;string name=&quot;roster_title&quot;&gt;Team Roster&lt;/string&gt;&#10;    &lt;string name=&quot;roster_members_count&quot;&gt;%1$d team member%2$s&lt;/string&gt;&#10;    &lt;string name=&quot;roster_empty_title&quot;&gt;No team members&lt;/string&gt;&#10;    &lt;string name=&quot;roster_empty_subtitle&quot;&gt;No team members configured&lt;/string&gt;&#10;    &lt;string name=&quot;roster_section_label&quot;&gt;TEAM MEMBERS&lt;/string&gt;&#10;    &lt;string name=&quot;roster_member_subtitle&quot;&gt;Team member %1$d&lt;/string&gt;&#10;&#10;    &lt;!-- Missing --&gt;&#10;    &lt;string name=&quot;missing_title&quot;&gt;Missing Standup&lt;/string&gt;&#10;    &lt;string name=&quot;missing_header&quot;&gt;Missing Today&lt;/string&gt;&#10;    &lt;string name=&quot;missing_members_count&quot;&gt;%1$d team member%2$s have not submitted&lt;/string&gt;&#10;    &lt;string name=&quot;missing_empty_title&quot;&gt;All caught up!&lt;/string&gt;&#10;    &lt;string name=&quot;missing_empty_subtitle&quot;&gt;Everyone has submitted today&lt;/string&gt;&#10;    &lt;string name=&quot;missing_row_subtitle&quot;&gt;Not submitted yet&lt;/string&gt;&#10;    &lt;string name=&quot;remind&quot;&gt;Remind&lt;/string&gt;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>